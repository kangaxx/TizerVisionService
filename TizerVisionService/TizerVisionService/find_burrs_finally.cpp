///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 20.11.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"


#include "find_burrs_finally.h"
#include "../../../hds/Logger.h"
#include "stdio.h"
//#define FLAG_TEST_BY_LOCAL_FILE 0 //使用本地文件调试算法现场工作时请屏蔽该宏

using namespace HalconCpp;
using namespace commonfunction_c;

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off();
// Local procedures 
void caculator_centor();
static int g_SaveTaichiNum = 0;


// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off()
{

    //This procedure sets different update settings to 'off'.
    //This is useful to get the best performance and reduce overhead.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop
    return;
}


// Local procedures 
void caculator_centor()
{

    return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 

BurrsPainter halconWorker::actionTaichi(int limit, int grayMin, int w, int h, const HBYTE* image)
{
	HObject Image;
	BurrsPainter result;
	result.setType(TYPE_BURRS_IMAGE_ERROR_NO_IMAGE); //刚开始没有图
	try {
		int distance = 0;
		hv_threshold_gray_min = grayMin;
		hv_threshold_gray_max = 255;
		hv_select_region_min = 14200;
		hv_burrs_limit = 55;
		//毛刺方向， 0 , horizontal(horiz) 横向全部 1, vertical(vert) 纵向全部
		hv_burrs_direction = INT_BURRS_DIRECTION_HORIZ;
		//比例尺, 40*1.1镜头是0.76， 该镜头加两个环是0.728624
		hv_zoom_scale = 0.7286;
		//基本功能测试用硬盘文件即可
#ifdef FLAG_TEST_BY_LOCAL_FILE
		/*  硬盘文件调试代码  */
		//ReadImage(&ho_Image, "d:/images/22_1.bmp");

		//result.setFileName("d:/images/22_1.bmp");
		/*  硬盘文件调试代码  */
#else
		GenImage1(&ho_Image, "byte", w, h, (Hlong)image); //由相机传入
#endif // FLAG_TEST_BY_LOCAL_FILE
		//test temporary

		ho_R = ho_Image;
		GetImageSize(ho_R, &hv_Width, &hv_Height);
		GrayClosingRect(ho_R, &ho_R, 2, 2);

		//第一个测量对象轮廓线中心点行坐标
		hv_MeasureStartRow = 0;
		//第一个测量对象轮廓线中心点列坐标

		hv_MeasureStartRow = 0;
		hv_MeasureStartCol = hv_Width / 2;
		hv_MeasurePhi = 0;
		//测量对象长轴
		hv_MeasureLength1 = hv_Width;
		//测量对象短轴
		hv_MeasureLength2 = 1;
		//寻边个数
		hv_FindEdgeNum = (hv_Height / hv_MeasureLength2) / 2;


		//显示窗口初始化
		dev_update_off();
		//part 1 寻找极片区域
		GenRectangle1(&ho_ROI, 0, 0, hv_Height, hv_Width);
		ReduceDomain(ho_R, ho_ROI, &ho_ImageReduce);
		//emphasize (ImageReduce, ImageEmphasize, Width, Height, 1.5)
		//mean_image (ImageReduce, Mean, 25, 25)
		//平滑处理图像
		//gray_opening_rect (Mean, ImageOpening, 2, 2)
		GrayClosingRect(ho_ImageReduce, &ho_ImageClosing, 15, 2);
		//亚像素边界
		//edges_sub_pix (Image, Edges, 'lanser2', 0.5, 8, 50)

		//dyn_threshold (ImageClosing, Mean, RegionsDyn, 3, 'light')

		Threshold(ho_ImageClosing, &ho_Regions, hv_threshold_gray_min, hv_threshold_gray_max);

		//计算极片倾斜度

		Connection(ho_Regions, &ho_Connects);

		SelectShape(ho_Connects, &ho_SelectedRegion, "area", "and", hv_select_region_min,
			9999999);
		SmallestRectangle2(ho_SelectedRegion, &hv_AngleRow, &hv_AngleColumn, &hv_AnglePhi,
			&hv_AngleL1, &hv_AngleL2);
		//打印极片外接矩
		GenRectangle2(&ho_RegionAngle, hv_AngleRow, hv_AngleColumn, hv_AnglePhi, hv_AngleL1,
			hv_AngleL2);

		RegionToBin(ho_SelectedRegion, &ho_ImageBin, 255, 50, hv_Width, hv_Height);

		hv_rotateAngle = (90 * (1.57079632675 - hv_AnglePhi)) / 1.57079632675;
		if (0 != (int(HTuple(hv_rotateAngle[0]) > 90)))
		{
			hv_rotateAngle[0] = HTuple(hv_rotateAngle[0]) - 180;
		}
		RotateImage(ho_ImageBin, &ho_ImageRotate, HTuple(hv_rotateAngle[0]), "constant");

		//图片选装后会有黑边，另外选中区域现在是白色，需要去边并且做负片运算
		Threshold(ho_ImageRotate, &ho_RegionRotate, 128, 255);
		RegionToBin(ho_RegionRotate, &ho_BinImage, 0, 255, hv_Width, hv_Height);


		//灰度值闭运算消除小引脚

		if (HDevWindowStack::IsOpen())
			SetLineWidth(HDevWindowStack::GetActive(), 2);
		if (HDevWindowStack::IsOpen())
			SetDraw(HDevWindowStack::GetActive(), "margin");
		//插值算法支持bilinear， bicubic, nearest_neighbor
		GenMeasureRectangle2(hv_MeasureStartRow, hv_MeasureStartCol, hv_MeasurePhi, hv_MeasureLength1,
			hv_MeasureLength2, hv_Width, hv_Height, "nearest_neighbor", &hv_MeasureHandle);
		//打印旋转后的原图

		RotateImage(ho_Image, &ho_ImageShow, HTuple(hv_rotateAngle[0]), "constant");
		{
			HTuple end_val137 = hv_FindEdgeNum;
			HTuple step_val137 = 1;
			int size = hv_FindEdgeNum.I();
			int* left = new int[size];
			int burrList[10];
			int measureIdx = 0;

			for (hv_Index = 1; hv_Index.Continue(end_val137, step_val137); hv_Index += step_val137)
			{
				//移动测量对象句柄
				TranslateMeasure(hv_MeasureHandle, hv_MeasureStartRow + ((2 * hv_MeasureLength2) * hv_Index),
					hv_MeasureStartCol);
				//根据测量变量生成Rectangle2（用于可视化，可注释掉）
				GenRectangle2(&ho_Rectangle, hv_MeasureStartRow + ((2 * hv_MeasureLength2) * hv_Index),
					hv_MeasureStartCol, hv_MeasurePhi, hv_MeasureLength1, hv_MeasureLength2);


				//测量并显示寻到的边界位置点
				MeasurePos(ho_BinImage, hv_MeasureHandle, 1, 30, "negative", "first", &hv_RowEdge,
					&hv_ColumnEdge, &hv_Amplitude, &hv_Distance);

				if (hv_RowEdge > 0) {
					left[measureIdx] = hv_ColumnEdge.TupleInt().I();
				}
				else {
					left[measureIdx] = 0;
				}
				measureIdx++;
				if (measureIdx >= size) {
					break;
				}
			}
			int leftAvg, inflection;
			int step = 100;
			int BurrsX[10];
			int BurrsY[10];
			int burrsIdx = 0;
			int MaxBurrValue = 0;
			int MaxBurrX = 0;
			int MaxBurrY = 0;
			bool isBurrs = false;

			for (int i = 0; i < end_val137; i = i + step - 1) {
				inflection = commonfunction_c::BaseFunctions::findInflection((const int*)&(left[0]), end_val137, i, i + step, TYPE_INFLECTION_MAX);
				if (inflection < 0) continue; //未找到极值
				leftAvg = commonfunction_c::BaseFunctions::getArrayAverage(&(left[0]), end_val137, i, i + step);
				if (left[inflection] - limit > leftAvg) {
					int burrLength = left[inflection] - leftAvg;
					float adjustBurrValue = adjustDis(burrLength, hv_zoom_scale, false);
					result.insertBurrSorted(left[inflection], inflection * 2, adjustBurrValue);
				}
			}
			result.setGrabImageHeight(hv_Height);
			result.setGrabImageWidth(hv_Width);
			delete[] left;
		}
		//关闭测量对象
		CloseMeasure(hv_MeasureHandle);

		//配置保存文件的文件名
		time_t t;
		time(&t);
		string stime;
		commonfunction_c::BaseFunctions::time2str(t, stime);
		string fileName;
		char number[10];
		if (result.getDistance(0) > 5.0) {
			m_TaichiAlert++;
			if (m_TaichiAlert > INT_ALERT_IMAGE_MAX_COUNT) {
				m_TaichiAlert = 1;
			}
			commonfunction_c::BaseFunctions::Int2Chars(m_TaichiAlert, number);
			fileName = "d:/grabs/tc_alert_" + string(number) + ".jpg";
			result.setType(TYPE_BURRS_IMAGE_TAICHI_BURR);
		}
		else {
			m_TaichiNormal++;
			if (m_TaichiNormal > INT_NORMAL_IMAGE_MAX_COUNT) {
				m_TaichiNormal = 1;
			}
			commonfunction_c::BaseFunctions::Int2Chars(m_TaichiAlert, number);
			fileName = "d:/grabs/tc_normal_" + string(number) + ".jpg";
			result.setType(TYPE_BURRS_IMAGE_TAICHI_NORMAL);
		}
		result.setFileName(fileName.c_str());
		result.setFileTime(stime.c_str());
		HImage imageForWrite = ho_BinImage;
		//HImage imageForWrite = ho_Image;

		if (result.getDistance(0) > 5.0) {
			imageForWrite = imageForWrite.ZoomImageFactor(0.5, 0.5, "bilinear");
			imageForWrite.WriteImage("jpg", 0, fileName.c_str());
		}
		else {
			g_SaveTaichiNum++;
			if (g_SaveTaichiNum % 10000 == 0) {
				imageForWrite = imageForWrite.ZoomImageFactor(0.5, 0.5, "bilinear");
				imageForWrite.WriteImage("jpg", 0, fileName.c_str());
				g_SaveTaichiNum = 0;
			}
		}
		Hlong zoomWidth, zoomHeight;
		imageForWrite.GetImageSize(&zoomWidth, &zoomHeight);
		result.setSaveImageWidth(zoomWidth);
		result.setSaveImageHeight(zoomHeight);
		return result;
	}
	catch (HException& exp) {
		try {
			if (image != 0 && w != 0 && h != 0) {
				//照相机模式下遇到异常需要尝试保存图像
				GenImage1Extern(&ho_Image, "byte", w, h, (Hlong)image, NULL);
				m_LongitudinalNormal++;
				if (m_LongitudinalNormal > INT_NORMAL_IMAGE_MAX_COUNT) {
					m_LongitudinalNormal = 1;
				}
				char number[5];
				sprintf_s(number, 5, "%d", m_LongitudinalNormal);
				string fileName = "d:/grabs/tc_normal_" + string(number) + ".jpg";
				result.setFileName(fileName.c_str());
				HImage imageForWrite = ho_Image;
				imageForWrite = imageForWrite.ZoomImageFactor(0.5, 0.5, "bilinear");
				imageForWrite.WriteImage("jpg", 0, fileName.c_str());
				Hlong zoomWidth, zoomHeight;
				imageForWrite.GetImageSize(&zoomWidth, &zoomHeight);
				result.setSaveImageWidth(zoomWidth);
				result.setSaveImageHeight(zoomHeight);
				result.setFileName(fileName.c_str());
				result.setType(TYPE_BURRS_IMAGE_TAICHI_NORMAL);
			}
			return result;
		}
		catch (HException e) {
			return result;
		}

	}
}



BurrsPainter halconWorker::action(bool v2h, int limit, int grayMin, int grayMax, int w, int h, const HBYTE* image, int polesWidth)
{
	BurrsPainter result;
	result.setType(TYPE_BURRS_IMAGE_ERROR_NO_IMAGE); //刚开始没有图
	try {
		//debug 为1时会打印过程图像
		hv_threshold_gray_min = grayMin;
		hv_threshold_gray_max = 255;
		hv_select_region_min = 4200;
		int distance = 0;
		hv_burrs_limit = limit;
		//预设极片宽度(包含允许的误差）
		hv_polesWidth = 25;
		//毛刺方向， 0 , horizontal(horiz) 横向全部 1, vertical(vert) 纵向全部
		hv_burrs_direction = INT_BURRS_DIRECTION_HORIZ;
		//比例尺, 40*1.1镜头是0.76， 该镜头加两个环是0.728624
		hv_zoom_scale = 0.7286;
		/*  硬盘文件调试代码  */
#ifdef FLAG_TEST_BY_LOCAL_FILE
		/*  硬盘文件调试代码  */
		ReadImage(&ho_Image, "d:/images/21_1.bmp");
		result.setFileName("d:/images/21_1.bmp");
		/*  硬盘文件调试代码  */
#else
		GenImage1Extern(&ho_Image, "byte", w, h, (Hlong)image, NULL); //由相机传入
#endif // FLAG_TEST_BY_LOCAL_FILE
		if (v2h) {
			ho_Image = imageVertToHoriz(ho_Image);
			hv_zoom_scale = hv_zoom_scale * 20.0 / 24.0;
		}
		//负极铜片的分切位置可以考虑用红色分量来处理
		hv_is_Bronze_Compose3 = 0;
		ho_R = ho_Image;
		if (0 != (int(hv_is_Bronze_Compose3 == 1)))
		{
			Decompose3(ho_Image, &ho_R, &ho_G, &ho_B);
		}
		GetImageSize(ho_R, &hv_Width, &hv_Height);
		GrayClosingRect(ho_R, &ho_R, 2, 2);
		//$第一步 查找极片区域
		//查找亚像素边界

		//**测量变量初始化**
		//第一个测量对象轮廓线中心点行坐标
		hv_MeasureStartRow = 0;
		//第一个测量对象轮廓线中心点列坐标
		hv_MeasureStartRow = 0;
		hv_MeasureStartCol = hv_Width / 2;
		hv_MeasurePhi = 0;
		//测量对象长轴
		hv_MeasureLength1 = hv_Width;
		//测量对象短轴
		hv_MeasureLength2 = 1;
		//寻边个数
		hv_FindEdgeNum = (hv_Height / hv_MeasureLength2) / 2;

		//part 1 寻找极片区域
		GenRectangle1(&ho_ROI, 0, 0, hv_Height, hv_Width);
		ReduceDomain(ho_R, ho_ROI, &ho_ImageReduce);
		//emphasize (ImageReduce, ImageEmphasize, Width, Height, 1.5)
		//mean_image (ImageReduce, Mean, 25, 25)
		//平滑处理图像
		//gray_opening_rect (Mean, ImageOpening, 2, 2)
		GrayClosingRect(ho_ImageReduce, &ho_ImageClosing, 15, 2);
		//亚像素边界
		//edges_sub_pix (Image, Edges, 'lanser2', 0.5, 8, 50)

		//dyn_threshold (ImageClosing, Mean, RegionsDyn, 3, 'light')

		Threshold(ho_ImageClosing, &ho_Regions, hv_threshold_gray_min, hv_threshold_gray_max);

		//计算极片倾斜度

		Connection(ho_Regions, &ho_Connects);

		SelectShape(ho_Connects, &ho_SelectedRegion, "area", "and", hv_select_region_min,
			199999);
		SmallestRectangle2(ho_SelectedRegion, &hv_AngleRow, &hv_AngleColumn, &hv_AnglePhi,
			&hv_AngleL1, &hv_AngleL2);
		//打印极片外接矩
		GenRectangle2(&ho_RegionAngle, hv_AngleRow, hv_AngleColumn, hv_AnglePhi, hv_AngleL1,
			hv_AngleL2);

		RegionToBin(ho_SelectedRegion, &ho_ImageBin, 255, 50, hv_Width, hv_Height);

		hv_rotateAngle = (90 * (1.57079632675 - hv_AnglePhi)) / 1.57079632675;
		if (0 != (int(HTuple(hv_rotateAngle[0]) > 90)))
		{
			hv_rotateAngle[0] = HTuple(hv_rotateAngle[0]) - 180;
		}
		RotateImage(ho_ImageBin, &ho_ImageRotate, HTuple(hv_rotateAngle[0]), "constant");
		//图片选装后会有黑边，另外选中区域现在是白色，需要去边并且做负片运算
		Threshold(ho_ImageRotate, &ho_RegionRotate, 128, 255);
		RegionToBin(ho_RegionRotate, &ho_BinImage, 20, 220, hv_Width, hv_Height);


		//灰度值闭运算消除小引脚

		if (HDevWindowStack::IsOpen())
			SetLineWidth(HDevWindowStack::GetActive(), 2);
		if (HDevWindowStack::IsOpen())
			SetDraw(HDevWindowStack::GetActive(), "margin");
		//插值算法支持bilinear， bicubic, nearest_neighbor
		GenMeasureRectangle2(hv_MeasureStartRow, hv_MeasureStartCol, hv_MeasurePhi, hv_MeasureLength1,
			hv_MeasureLength2, hv_Width, hv_Height, "nearest_neighbor", &hv_MeasureHandle);
		//打印旋转后的原图

		RotateImage(ho_Image, &ho_ImageShow, HTuple(hv_rotateAngle[0]), "constant");
		{
			HTuple end_val137 = hv_FindEdgeNum;
			HTuple step_val137 = 1;
			int size = hv_FindEdgeNum.I();
			int* left = new int[size];
			int* right = new int[size];
			int* width = new int[size];
			int burrList[10];
			int measureIdx = 0;
			for (hv_Index = 1; hv_Index.Continue(end_val137, step_val137); hv_Index += step_val137)
			{
				//移动测量对象句柄
				TranslateMeasure(hv_MeasureHandle, hv_MeasureStartRow + ((2 * hv_MeasureLength2) * hv_Index),
					hv_MeasureStartCol);
				//根据测量变量生成Rectangle2（用于可视化，可注释掉）
				GenRectangle2(&ho_Rectangle, hv_MeasureStartRow + ((2 * hv_MeasureLength2) * hv_Index),
					hv_MeasureStartCol, hv_MeasurePhi, hv_MeasureLength1, hv_MeasureLength2);


				//测量并显示寻到的边界位置点
				MeasurePos(ho_BinImage, hv_MeasureHandle, 1, 30, "negative", "first", &hv_RowEdge,
					&hv_ColumnEdge, &hv_Amplitude, &hv_Distance);
				MeasurePos(ho_BinImage, hv_MeasureHandle, 1, 30, "positive", "last", &hv_RowEdgeR,
					&hv_ColumnEdgeR, &hv_Amplitude, &hv_Distance);

				if (hv_RowEdge > 0 && hv_RowEdgeR > 0) {
					left[measureIdx] = hv_ColumnEdge.TupleInt().I();
					right[measureIdx] = hv_ColumnEdgeR.TupleInt().I();
					width[measureIdx] = right[measureIdx] - left[measureIdx];
				}
				else {
					left[measureIdx] = 0;
					right[measureIdx] = 0;
					width[measureIdx] = 0;
				}
				measureIdx++;
				if (measureIdx >= size) {
					break;
				}
			}

			int BurrsX[10];
			int BurrsY[10];
			int BurrsValue[10];
			int burrsIdx = 0;
			int BurrValue = 0;
			int BurrX_Left = 0;
			int BurrX_Right = 0;
			int BurrX = 0;
			int BurrY = 0;
			int MaxBurrValue = 0;
			int MaxBurrX = 0;
			int MaxBurrY = 0;
			//以下算法能够找到毛刺并且确定毛刺的方向
			int i = 0;
			int leftAvg, rightAvg, widthAvg, widthInflection;
			int step = 100;
			for (int i = 0; i < end_val137; i = i + step - 1) {
				widthInflection = commonfunction_c::BaseFunctions::findInflection((const int*)&(width[0]), end_val137, i, i + step, TYPE_INFLECTION_MAX);
				if (widthInflection < 0) continue; //未找到极致
				leftAvg = commonfunction_c::BaseFunctions::getArrayAverage(&(left[0]), end_val137, i, i + step);
				rightAvg = commonfunction_c::BaseFunctions::getArrayAverage(&(right[0]), end_val137, i, i + step);
				widthAvg = commonfunction_c::BaseFunctions::getArrayAverage(&(width[0]), end_val137, i, i + step);
				//毛刺判断的要求是， 宽度超过设定极片宽度，并且有一定的突起
				if (width[widthInflection] > hv_polesWidth[0].I() && width[widthInflection] - widthAvg > (step / 10)) {
					if ((leftAvg - left[widthInflection]) > (right[widthInflection] - rightAvg))
						BurrX = left[widthInflection];
					else
						BurrX = right[widthInflection];
					BurrY = widthInflection * 2;
					//BurrValue = width[widthInflection] - hv_polesWidth;
					BurrValue = leftAvg - left[widthInflection];

				}
				float adjustBurrValue = adjustDis(BurrValue, hv_zoom_scale, false);
				result.insertBurrSorted(BurrX, BurrY, adjustBurrValue);

			}
			//distance = MaxBurrValue;
			/**/


			//result.setMaxBurrX(MaxBurrX);
			//result.setMaxBurrY(MaxBurrY);
			result.setGrabImageHeight(hv_Height);
			result.setGrabImageWidth(hv_Width);
			delete[] left;
			delete[] right;
			delete[] width;
		}

		hv_Distance = (float)distance * hv_zoom_scale;


		//关闭测量对象
		CloseMeasure(hv_MeasureHandle);
		string fileName;
		time_t t;
		time(&t);
		string stime;
		commonfunction_c::BaseFunctions::time2str(t, stime);
		char number[5];
		if (distance > 0) {
			m_LongitudinalAlert++;
			if (m_LongitudinalAlert > INT_ALERT_IMAGE_MAX_COUNT) {
				m_LongitudinalAlert = 1;
			}
			sprintf_s(number, 5, "%d", m_LongitudinalAlert);
			fileName = "d:/grabs/la_alert_" + string(number) + ".jpg";
			result.setType(TYPE_BURRS_IMAGE_EDGE_BURR);
		}
		else {
			m_LongitudinalNormal++;
			if (m_LongitudinalNormal > INT_NORMAL_IMAGE_MAX_COUNT) {
				m_LongitudinalNormal = 1;
			}
			sprintf_s(number, 5, "%d", m_LongitudinalNormal);
			fileName = "d:/grabs/la_normal_" + string(number) + ".jpg";
			result.setType(TYPE_BURRS_IMAGE_EDGE_NORMAL);
		}
		HImage imageForWrite = ho_ImageShow;
		imageForWrite = imageForWrite.ZoomImageFactor(0.5, 0.5, "bilinear");
		imageForWrite.WriteImage("jpg", 0, fileName.c_str());
		Hlong zoomWidth, zoomHeight;
		imageForWrite.GetImageSize(&zoomWidth, &zoomHeight);
		result.setSaveImageWidth(zoomWidth);
		result.setSaveImageHeight(zoomHeight);
		result.setFileName(fileName.c_str());
		result.setFileTime(stime.c_str());


		return result;
	}
	catch (HException& exp) {
		try {
			if (image != 0 && w != 0 && h != 0) {
				//照相机模式下遇到异常需要尝试保存图像
				GenImage1Extern(&ho_Image, "byte", w, h, (Hlong)image, NULL);
				m_LongitudinalNormal++;
				if (m_LongitudinalNormal > INT_NORMAL_IMAGE_MAX_COUNT) {
					m_LongitudinalNormal = 1;
				}
				char number[5];
				sprintf_s(number, 5, "%d", m_LongitudinalNormal);
				string fileName = "d:/grabs/la_normal_" + string(number) + ".jpg";
				result.setFileName(fileName.c_str());
				HImage imageForWrite = ho_Image;
				imageForWrite = imageForWrite.ZoomImageFactor(0.5, 0.5, "bilinear");
				imageForWrite.WriteImage("jpg", 0, fileName.c_str());
				Hlong zoomWidth, zoomHeight;
				imageForWrite.GetImageSize(&zoomWidth, &zoomHeight);
				result.setSaveImageWidth(zoomWidth);
				result.setSaveImageHeight(zoomHeight);
				result.setFileName(fileName.c_str());
				result.setType(TYPE_BURRS_IMAGE_EDGE_NORMAL);
			}
			return result;
		} 
		catch (HException e) {
			return result;
		}

	}
}

HImage halconWorker::imageVertToHoriz(const HImage source, int angle)
{
	HImage result;
	RotateImage(source, &result, angle, "constant");
	return result;
}

float halconWorker::adjustDis(int& value, float zoom, bool doAdjust)
{
	float distance = (float)value * zoom;
	if (!doAdjust)
		return distance;
	float adjust = 0.0;
	if (distance > 0 && distance < 2.0) {
		return 2.0 - sqrt(2.0 - distance);
	}
	else if (distance <= 3.0) {
		return 4.0 - sqrt(4.0 - distance);
	}
	else if (distance > 4.0 && distance <= 7.0) {
		return 8.0 - sqrt(8.0 - distance);
	}
	else if (distance > 8.0 && distance <= 11.0) {
		return 12.0 - sqrt(12.0 - distance);
	}
	else if (distance > 12.0 && distance <= 15.0) {
		return 16.0 - sqrt(16.0 - distance);
	}
	else if (distance > 16.0 && distance <= 19.0) {
		//太大的毛刺尽量减小点
		return 15.0 + sqrt(distance - 15.0);
	}
	else if (distance > 18.0 && distance <= 23.0) {
		return sqrt(distance - 18.0) + 18.0;
	}
	else {
		return distance;
	}

	return 0.0f;
}


#ifndef NO_EXPORT_APP_MAIN

BurrsPainter halconWorker::halconAction(int limit, int grayMin, int grayMax, int width, int height, const HBYTE* image, int polesWidth)
{
    BurrsPainter result;
    result.setBurrsNum(0);
    try
    {
#if defined(_WIN32)
        SetSystem("use_window_thread", "true");
#endif

        // file was stored with local-8-bit encoding
        //   -> set the interface encoding accordingly
        SetHcppInterfaceStringEncodingIsUtf8(false);

        // Default settings used in HDevelop (can be omitted)


        return action(true, limit, grayMin, grayMax, width, height, image);

    }
    catch (HException& exception)
    {
        /*
        fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
                exception.ProcName().TextA(),
                exception.ErrorMessage().TextA());
        */

    }
    return result;
}

BurrsPainter halconWorker::halconActionTaichi(int limit, int grayMin, int width, int height, const HBYTE* image)
{
	BurrsPainter result;
	result.setBurrsNum(0);
	try
	{
#if defined(_WIN32)
		SetSystem("use_window_thread", "true");
#endif

		// file was stored with local-8-bit encoding
		//   -> set the interface encoding accordingly
		SetHcppInterfaceStringEncodingIsUtf8(false);
		// Default settings used in HDevelop (can be omitted)
		return actionTaichi(limit, grayMin, width, height, image);
	}
	catch (HException& exception)
	{
		/*
		fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
				exception.ProcName().TextA(),
				exception.ErrorMessage().TextA());
		*/
		FILE* fp;
		fopen_s(&fp, "c:/tizer/error.txt", "w");
		if (fp)
		{
			fprintf(fp, "error in defect find burrs thread \n");
			fclose(fp);
		}
	}
	return result;
}

#endif


#endif


