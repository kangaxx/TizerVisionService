#include "JmjCornerAlignmentHalcon.h"
#define THRESHOLD_VALUE 128
#define SELECT_SHAPE_AREA_MIN 30000
#define SELECT_SHAPE_AREA_MAX 99999
char** halcon_program(int argc, char* in[], HImage& image, char** out)
{
    JmjCornerAlignmentHalcon jmj_halcon(argc, in, image);
    try
    {
        jmj_halcon.get_log().linkable_log(L"Jmj halcon cross aligment caculation library, version ")
            .linkable_log(STR_VER_FULL);
        char* json_input = in[0];
        JsonHelper jh(json_input);
        int id = BaseFunctions::Str2Int(jh.search("id"));
        jmj_halcon.do_find_cross(id, out);
    }
    catch (HalconCpp::HException& exception)
    {
        std::string messageFmt = "  Error #%u in %s: %s\n";
        char message[2048];
        sprintf_s(message, 2048, messageFmt.c_str(), exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
        jmj_halcon.get_log().Log(message);
        return out;
    }

    return out;
}

void JmjCornerAlignmentHalcon::do_find_cross(int id, char** result)
{
    //根据全图色彩分布判断是深色背景还是浅色背景
    //0 - 十字颜色是黑色的，背景是白色的； 1 - 十字颜色是白色的，背景是黑色的
    HTuple hv_cross_color_type = 0;
    HObject region_bg;
    Threshold(*_image, &region_bg, 0, 120); //深色面积
    HTuple area;
    HalconCpp::AreaCenter(region_bg, &area, 0, 0);
    HTuple width, height;
    _image->GetImageSize(&width, &height);
    //深色面积较大考虑设置十字颜色为白色
    if (area > width * height * 0.2)
        hv_cross_color_type = 1;
    
    //设置参考校准点位（演示功能)
    HTuple hv_row_center = width / 2;
    HTuple hv_col_center = height / 2;
    HObject ho_region;
    if (0 != (int(hv_cross_color_type == 0)))
    {
        //cross_color_type : 0 - 十字颜色是黑色的，背景是白色的
        Threshold(*_image, &ho_region, 0, THRESHOLD_VALUE);
    }
    else if (0 != (int(hv_cross_color_type == 1)))
    {
        //cross_color_type : 1 - 十字颜色是白色的，背景是黑色的
        Threshold(*_image, &ho_region, THRESHOLD_VALUE, 255);
    }
    HRegion ho_region_open, ho_connected_regions, ho_selected_regions;
    OpeningCircle(ho_region, &ho_region_open, 2);
    Connection(ho_region_open, &ho_connected_regions);
    SelectShape(ho_connected_regions, &ho_selected_regions, "area", "and", SELECT_SHAPE_AREA_MIN, SELECT_SHAPE_AREA_MAX);
    HTuple row, column, phi;
    SmallestRectangle2(ho_selected_regions, &row, &column, &phi, 0, 0);
    //倾斜角度
    HTuple hv_phi_du = (phi * 180) / 3.14;
    HObject circle;
    GenCircle(&circle, row, column, 50);
    ClosingCircle(ho_selected_regions, &ho_selected_regions, 25);
    HObject ho_skeleton, ho_contours, ho_select_xld, ho_region_skeleton, ho_region_dilation;
    Skeleton(ho_selected_regions, &ho_skeleton);
    GenContoursSkeletonXld(ho_skeleton, &ho_contours, 1, "generalize1");
    SelectShapeXld(ho_contours, &ho_select_xld, "contlength", "and", 100, 900);
    GenRegionContourXld(ho_select_xld, &ho_region_skeleton, "filled");
    DilationRectangle1(ho_region_skeleton, &ho_region_dilation, 18, 18);
    HTuple hv_Number;
    CountObj(ho_region_dilation, &hv_Number);
    HObject ho_object_selected, ho_object_selected_01, ho_intersection_circle, ho_region_intersection;
    SelectObj(ho_region_dilation, &ho_object_selected, 1);
    {
        HTuple end_val89 = hv_Number;
        HTuple step_val89 = 1;
        HTuple hv_i, hv_area;
        for (hv_i = 2; hv_i.Continue(end_val89, step_val89); hv_i += step_val89)
        {
            SelectObj(ho_region_dilation, &ho_object_selected_01, hv_i);
            Intersection(ho_object_selected_01, circle, &ho_intersection_circle);
            AreaCenter(ho_intersection_circle, &hv_area, 0, 0);
            if (0 != (int(hv_area > 0)))
            {
                Intersection(ho_object_selected, ho_object_selected_01, &ho_region_intersection);
            }
            //stop ()
        }
    }
    HTuple cross_area, cross_row, cross_column;
    AreaCenter(ho_region_intersection, &cross_area, &cross_row, &cross_column);
    //将被测物坐标转换为世界坐标计算便宜尺寸
    //相机标定部分,现有参数是写死的后续改为读config文件， by gxx
  //Calibration 01: Code generated by Calibration 01
    HTuple camera_parameters, camera_pose;
    camera_parameters.Clear();
    camera_parameters[0] = "area_scan_division";
    camera_parameters[1] = 0.324057;
    camera_parameters[2] = -10.6795;
    camera_parameters[3] = 8.30014e-06;
    camera_parameters[4] = 8.3e-06;
    camera_parameters[5] = 2338.79;
    camera_parameters[6] = 1337.24;
    camera_parameters[7] = 4024;
    camera_parameters[8] = 3036;
    camera_pose.Clear();
    camera_pose[0] = 0.0170848;
    camera_pose[1] = 0.0391668;
    camera_pose[2] = 10.3302;
    camera_pose[3] = 359.576;
    camera_pose[4] = 0.256305;
    camera_pose[5] = 0.0014028;
    camera_pose[6] = 0;
    HImage calib_image;
    ReadImage(&calib_image, "D:/github/halcon_demo/jmj/49pt_calibration_jmj.bmp");
    //Calibration 01: Extract plate data from the image
    HTuple plate_description = "D:/github/halcon_demo/jmj/caltab.descr";
    HTuple cross_world_y, cross_world_x, center_world_y, center_world_x, distance;
    halconUtils::HalconCalibrationHelper::ImagePoint2WorldPlane(camera_parameters, camera_pose, plate_description,
        calib_image, cross_row, cross_column, cross_world_y, cross_world_x);
    halconUtils::HalconCalibrationHelper::ImagePoint2WorldPlane(camera_parameters, camera_pose, plate_description,
        calib_image, hv_row_center, hv_col_center, center_world_y, center_world_x);
    DistancePp(center_world_y, center_world_x, cross_world_y, cross_world_x, &distance);
    char message[2048];
    std::string messageFmt = "{\"id\":%d, \"distance\":%f,\"distance_x\":%f,\"distance_y\":%f,\"phi\":%f,\"time\":\"%s\"}";
    HTuple distance_x, distance_y;
    distance_x = cross_world_x - center_world_x;
    distance_y = cross_world_y - center_world_y;
    sprintf_s(message, 2048, messageFmt.c_str(), id, distance, distance_x, distance_y, BaseFunctions::getNowTimeString());
    strncpy_s(*result, 2048, message, 2048);
}
