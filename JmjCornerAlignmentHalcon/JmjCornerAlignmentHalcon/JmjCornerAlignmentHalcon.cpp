#include "JmjCornerAlignmentHalcon.h"
#define THRESHOLD_VALUE 128
#define SELECT_SHAPE_AREA_MIN 30000
#define SELECT_SHAPE_AREA_MAX 99999
char** halcon_program(int argc, char* in[], HImage& image, char** out)
{
    JmjCornerAlignmentHalcon jmj_halcon(argc, in, image);
    try
    {
        jmj_halcon.get_log().linkable_log(L"Jmj halcon cross aligment caculation library, version ")
            .Log(STR_VER_FULL);
        char* json_input = in[0];
        JsonHelper jh(json_input);
        int id = BaseFunctions::Str2Int(jh.search("id"));
        jmj_halcon.do_find_cross(id, out);
    }
    catch (HalconCpp::HException& exception)
    {
        std::string messageFmt = "  Error #%u in %s: %s\n";
        char message[2048];
        sprintf_s(message, 2048, messageFmt.c_str(), exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
        jmj_halcon.get_log().Log(message);
        return out;
    }
    return out;
}

void JmjCornerAlignmentHalcon::do_find_cross(int id, char** result)
{

    //根据全图色彩分布判断是深色背景还是浅色背景
    //0 - 十字颜色是黑色的，背景是白色的； 1 - 十字颜色是白色的，背景是黑色的
    HTuple hv_window_handle;
    HTuple hv_cross_color_type = 0;
    HObject region_bg;
    Threshold(*_image, &region_bg, 0, 120); //深色面积
    HTuple area;
    HalconCpp::AreaCenter(region_bg, &area, 0, 0);
    HTuple width, height;
    _image->GetImageSize(&width, &height);
    //创建window handle为后续修改图像做准备
    SetWindowAttr("background_color", "black");
    OpenWindow(0, 0, width * _image_zoom_value, height * _image_zoom_value, 0, "visible", "", &hv_window_handle);
    HDevWindowStack::Push(hv_window_handle);
    //设置区域填充 边缘
    if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(), "margin");
    //设置颜色
    if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(), "red");
    //底图
    HObject ho_image = *_image;
    if (HDevWindowStack::IsOpen())
        DispObj(ho_image, HDevWindowStack::GetActive());

    //深色面积较大考虑设置十字颜色为白色
    if (area > width * height * 0.2)
        hv_cross_color_type = 1;    
    //设置参考校准点位（演示功能)
    HTuple hv_row_center = width / 2;
    HTuple hv_col_center = height / 2;
    HObject ho_region;
    if (0 != (int(hv_cross_color_type == 0)))
    {
        //cross_color_type : 0 - 十字颜色是黑色的，背景是白色的
        Threshold(*_image, &ho_region, 0, THRESHOLD_VALUE);
    }
    else if (0 != (int(hv_cross_color_type == 1)))
    {
        //cross_color_type : 1 - 十字颜色是白色的，背景是黑色的
        Threshold(*_image, &ho_region, THRESHOLD_VALUE, 255);
    }
    HRegion ho_region_open, ho_connected_regions, ho_selected_regions;
    OpeningCircle(ho_region, &ho_region_open, 2);
    Connection(ho_region_open, &ho_connected_regions);
    SelectShape(ho_connected_regions, &ho_selected_regions, "area", "and", SELECT_SHAPE_AREA_MIN, SELECT_SHAPE_AREA_MAX);
    HTuple row, column, phi;
    SmallestRectangle2(ho_selected_regions, &row, &column, &phi, 0, 0);
    //倾斜角度
    HTuple hv_phi_du = (phi * 180) / 3.14;
    HObject circle;
    GenCircle(&circle, row, column, 50);
    ClosingCircle(ho_selected_regions, &ho_selected_regions, 25);
    HObject ho_skeleton, ho_contours, ho_select_xld, ho_region_skeleton, ho_region_dilation;
    Skeleton(ho_selected_regions, &ho_skeleton);
    GenContoursSkeletonXld(ho_skeleton, &ho_contours, 1, "generalize1");
    SelectShapeXld(ho_contours, &ho_select_xld, "contlength", "and", 100, 900);
    GenRegionContourXld(ho_select_xld, &ho_region_skeleton, "filled");
    DilationRectangle1(ho_region_skeleton, &ho_region_dilation, 18, 18);
    HTuple hv_Number;
    CountObj(ho_region_dilation, &hv_Number);
    HObject ho_object_selected, ho_object_selected_01, ho_intersection_circle, ho_region_intersection;
    SelectObj(ho_region_dilation, &ho_object_selected, 1);
    {
        HTuple end_val89 = hv_Number;
        HTuple step_val89 = 1;
        HTuple hv_i, hv_area;
        for (hv_i = 2; hv_i.Continue(end_val89, step_val89); hv_i += step_val89)
        {
            SelectObj(ho_region_dilation, &ho_object_selected_01, hv_i);
            Intersection(ho_object_selected_01, circle, &ho_intersection_circle);
            AreaCenter(ho_intersection_circle, &hv_area, 0, 0);
            if (0 != (int(hv_area > 0)))
            {
                Intersection(ho_object_selected, ho_object_selected_01, &ho_region_intersection);
            }
            //stop ()
        }
    }
    HTuple cross_area, cross_row, cross_column;
    AreaCenter(ho_region_intersection, &cross_area, &cross_row, &cross_column);
    //将被测物坐标转换为世界坐标计算便宜尺寸
    //相机标定部分,现有参数是写死的后续改为读config文件， by gxx
  //Calibration 01: Code generated by Calibration 01
    HTuple camera_parameters, camera_pose;
    camera_parameters.Clear();
    /*
    camera_parameters[0] = "area_scan_division";
    camera_parameters[1] = 0.324057;
    camera_parameters[2] = -10.6795;
    camera_parameters[3] = 8.30014e-06;
    camera_parameters[4] = 8.3e-06;
    camera_parameters[5] = 2338.79;
    camera_parameters[6] = 1337.24;
    camera_parameters[7] = 4024;
    camera_parameters[8] = 3036;

    camera_pose.Clear();
    camera_pose[0] = 0.0170848;
    camera_pose[1] = 0.0391668;
    camera_pose[2] = 10.3302;
    camera_pose[3] = 359.576;
    camera_pose[4] = 0.256305;
    camera_pose[5] = 0.0014028;
    camera_pose[6] = 0;
        */
    HImage calib_image;
    ReadImage(&calib_image, _calibration_file_name.c_str());
    //Calibration 01: Extract plate data from the image
    HTuple plate_description = _plate_desc.c_str();
    HTuple cross_world_y, cross_world_x, center_world_y, center_world_x, distance;
    halconUtils::HalconCalibrationHelper::ImagePoint2WorldPlane(_camera_parameters, _camera_poses, plate_description,
        calib_image, cross_row, cross_column, cross_world_y, cross_world_x);
    halconUtils::HalconCalibrationHelper::ImagePoint2WorldPlane(_camera_parameters, _camera_poses, plate_description,
        calib_image, hv_row_center, hv_col_center, center_world_y, center_world_x);
    DistancePp(center_world_y, center_world_x, cross_world_y, cross_world_x, &distance);
    char image_text[200];
    sprintf_s(image_text, 200, "center distance: %f mm, rotate angle: %f", distance.D(), hv_phi_du.D());
    WriteString(hv_window_handle, image_text);
    //dump保存标注后的图像文件
    char image_file[40];
    sprintf_s(image_file, 40, "d:/Images/dump_image_%d.bmp", id);
    HObject ho_cross;
    GenCrossContourXld(&ho_cross, cross_row, cross_column, 40, 0);
    if (HDevWindowStack::IsOpen())
        DispObj(ho_cross, HDevWindowStack::GetActive());
    HImage dump_image;
    DumpWindowImage(&dump_image, hv_window_handle);
    dump_image.WriteImage("bmp", 0, image_file);
    char message[2048];
    std::string messageFmt = "{\"id\":%d, \"distance\":%f,\"distance_x\":%f,\"distance_y\":%f,\"phi\":%f,\"image\":\"%s\",\"camera_tag\":\"%s\",\"time\":\"%s\"}";
    HTuple distance_x, distance_y;
    distance_x = cross_world_x - center_world_x;
    distance_y = cross_world_y - center_world_y;
    sprintf_s(message, 2048, messageFmt.c_str(), id, distance.D(), distance_x.D(), distance_y.D(), hv_phi_du.D(), image_file, _camera_tag.c_str(), BaseFunctions::getNowTimeString().c_str());
    strncpy_s(*result, 2048, message, 2048);
    if (HDevWindowStack::IsOpen())
        CloseWindow(HDevWindowStack::Pop());
}

void JmjCornerAlignmentHalcon::load_halcon_calib_data()
{
    JsonHelper jh_calib;
    vector<string> vec_camera_params, vec_camera_poses;
    jh_calib.initialByFile(_calib_dir + "\\" + "jmj.calib");
    int parameters_num = jh_calib.read_array<string>("camera_parameters", vec_camera_params);
    _camera_parameters[0] = vec_camera_params.at(0).c_str();
    for (int i = 1; i < parameters_num; ++i) {
        double d_val = BaseFunctions::str2d(vec_camera_params.at(i));
        _camera_parameters[i] = d_val;
    }
    int pose_num = jh_calib.read_array<string>("camera_pose", vec_camera_poses);
    for (int i = 0; i < pose_num; ++i) {
        double d_val = BaseFunctions::str2d(vec_camera_poses.at(i));
        _camera_poses[i] = d_val;
    }
    _calibration_file_name = jh_calib.search("calib_file");
    _plate_desc = jh_calib.search("plate_desc");
}
